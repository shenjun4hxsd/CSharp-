##继承

&emsp;&emsp;继承是 OOP 最重要的特性之一。任何类都可以从另一个类中继承，这就是说，这个类拥有它继承的类的所有成员。在 OOP 中，被继承（也称为派生）的类称为父类（也称为基类）。注意 ⚠️，C#中的对象仅能直接派生于一个基类，当然基类也可以有自己的基类。

&emsp;&emsp;继承性可以从一个较一般的基类扩展或创建更多的特定类。例如，考虑一个代表农场家畜的类。这个类名 `Animal`，拥有 `EatFood()` 或 `Breed()` 等方法，我们可以创建一个派生类 `Cow`，支持所有这些方法，它也有自己的方法，如 `Moo()` 和 `SupplyMilk()`。还可以创建另一个派生类 `Chicken`，该类有 `Cluck()` 和 `LayEgg()` 方法。

&emsp;&emsp;在 UML 中，用箭头表示继承，`如图 8-7 所示`。

![图 8-7](/assets/8-7.png)

>&emsp;&emsp;**为简洁起见，`图 8-7` 中省略了成员的返回类型。**

&emsp;&emsp;在继承一个基类时，成员的可访问性就成了一个重要的问题。派生类不能访问基类的私有成员，但可以访问其公共成员。不过，派生类和外部的代码都可以访问公共成员，而不能由外部的代码访问。

&emsp;&emsp;为了解决这个问题，C#提供了第三种可访问性：`protected`，只有派生类才能访问 `protected` 成员。对于外部代码来说，这个可访问性与私有成员一样：外部代码不能访问 `private` 成员和 `protected` 成员。

&emsp;&emsp;除了定义成员的保护级别外，我们还可以为成员定义其继承行为。基类的成员可以是虚拟的，也就是说，成员可以由继承它的类重写。派生类可以提供成员的另一种实现代码。这种代码不会删除原来的代码，仍可以在类中访问原来的代码，但外部代码不能访问它们。如果没有提供其他实现方式，通过派生类使用成员的外部代码就自动访问基类中成员的实现代码。


>&emsp;&emsp;**虚拟成员不能是私有成员，因为这样会自相矛盾--不能既要求派生类重写成员，又不让派生类访问该成员。**

&emsp;&emsp;在前面的家畜示例中，可以把 `EatFood()` 变成虚拟成员，在派生类中为它提供新的实现代码，例如为 `Cow` 类提供新实现代码，如图 8-8 所示。这里显示了 `Animal` 和 `Cow` 类的 `EatFood()` 方法，说明它们有自己的实现代码。

&emsp;&emsp;基类还可以定义为抽象类。抽象类不能直接实例化。要使用抽象类，必须继承这个类，抽象类可以有抽象成员，这些成员在基类中没有实现代码，所以派生类必须实现它们。如果 `Animal` 是一个抽象类，UML 就会如图 8-9 所示。

![图 8-8](/assets/8-8.png)

>&emsp;&emsp;**抽象类名以斜体显示（有时它们的方框有一个短横线）。**

&emsp;&emsp;在 `图 8-9` 中，`EatFood()` 和 `Breed()` 都显示在派生类 `Chicken` 和 `Cow` 中，这说明这些方法是抽象的（必须在派生类中重写）或者虚拟的（这里已经在 `Chicken` 和 `Cow` 中重写）。当然，抽象基类可以提供成员的实现代码，这是十分常见的。不能实例化抽象类，并不意味着不能在抽象类中封装功能。

 &emsp;&emsp;最后，类可以是密封（ `seal` ）的。密封的类不能用作基类，所以没有派生类。

&emsp;&emsp;在C#中，所有对象都有一个共同的基类 `object` （在 .NET Framework 中，它是 System.Object 类的别名）。第 9 章将详细介绍这个类。

>&emsp;&emsp;**如本章前面所述，接口也可以继承自其他接口。与类不同的是，接口可以继承多个基接口（与类可以支持多个接口的方式类似）。**



🔚