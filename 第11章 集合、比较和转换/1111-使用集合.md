##使用集合

&emsp;&emsp;System.Collections 名称空间中的类 System.Collections.ArrayList 也实现了 IList、ICollection 和 IEnumerable 接口，但实现方式比 System.Array 更复杂。数组的大小是固定不变的（不能添加或删除元素），而这个类可以用于表示大小可变的项列表。为了更准确地理解这个高级集合的功能，下面列举一个使用这个类和一个简单数组的示例。

>&emsp;&emsp;数组和高级集合：Ch11Ex01

>&emsp;&emsp;（1）在 `C:\BegVCSharp\Chapter11` 目录中创建一个新的控制台应用程序 `Ch11Ex01`。

>&emsp;&emsp;（2）在 `解决方案资源管理器` 窗口中右击项目，选择 `Add | Class` 选项，给项目添加 3 个新类： `Animal`、`Cow` 和 `Chicken`。

>&emsp;&emsp;（3）修改 `Animal.cs` 中的代码，如下所示：


```javascript
    namespace Ch11Ex01
    {
        public abstract class Animal
        {
            protected string name;
            public string Name
            {
                get {
                    return name;
                }
                set {
                    name = value;
                }
            }

            public Animal()
            {
                name = "The animal with no name";
            }

            public Animal(string newName)
            {
                name = newName;
            }

            public void Feed()
            {
                Console.WriteLine("{0} has been fed.", name);
            }
        }
    }
```

>&emsp;&emsp;（4）修改 `Cow.cs` 中的代码，如下所示：

```javascript
    namespace Ch11Ex01
    {
        public class Cow : Animal
        {
            public void Milk()
            {
                Console.WriteLine("{0} has been milked.", name);
            }

            public Cow(string newName) : base(newName)
            {
            }
        }
    }
```

>&emsp;&emsp;（5）修改 `Chicken.cs` 中的代码，如下所示：

```javascript
    namespace Ch11Ex01
    {
        public class Chicken : Animal
        {
            public void LayEgg()
            {
                Console.WriteLine("{0} has laid an egg.", name);
            }

            public Chicken(string newName) : base(newName)
            {
            }
        }
    }
```

>&emsp;&emsp;（6）修改 `Program.cs` 中的代码，如下所示：

```javascript
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using Syste.Threading.Tasks;

    namespace Ch11Ex01
    {
        class Program
        {
            static void Main(string[] args)
            {
                Console.WriteLine("Create an Array type collection of Animal " + 
                                  "objects and use it:");
                Animal[] animalArray = new Animal[2];
                Cow myCow1 = new Cow("Deirdre");
                animalArray[0] = myCow1;
                animalArray[1] = new Chicken("Ken");

                foreach (Animal myAnimal in animalArray)
                {
                    Console.WriteLine("New {0} object added to Array collection, " + 
                                       "Name = {1}", myAnimal.ToString(), myAnimal.Name);
                }

                Console.WriteLine("Array collection contains {0} objects.", animalArray.Length);
                animalArray[0].Feed();
                ((Chicken)animalArray[1]).LayEgg();
                Console.WriteLine();

                Console.WriteLine("Create an ArrayList type collection of Animal " + 
                                  "objects and use it: ");
                ArrayList animalArrayList = new ArrayList();
                Cow myCow2 = new Cow("Hayley");
                animalArrayList.Add(myCow2);
                animalArrayList.Add(new Chicken("Roy"));

                foreach (Animal myAnimal in animalArrayList)
                {
                    Console.WriteLine("New {0} object added to ArrayList collection, " + 
                                      "Name = {1}", myAnimal.ToString(), myAnimal.Name);
                }
                Console.WriteLine("ArrayList collection contains {0} objects.", animalArrayList.Count);
                ((Animal)animalArrayList[0]).Feed();
                ((Chicken)animalArrayList[1]).LayEgg();
                Console.WriteLine();

                Console.WriteLine("Additional manipulation of ArrayList:");
                animalArrayList.RemoveAt(0);
                ((Animal)animalArrayList[0]).Feed();
                animalArrayList.AddRange(animalArray);
                ((Chicken)animalArrayList[2]).LayEgg();
                Console.WriteLine("The animal called {0} is at index {1}.", myCow1.Name, animalArrayList.IndexOf(myCow1));
                myCow1.Name = "Janice";
                Console.WriteLine("The animal is now called {0}.", ((Animal)animalArrayList[1]).Name);
                Console.ReadKey();     
            }
        }
    }
```


>&emsp;&emsp;**示例的说明**

&emsp;&emsp;这个示例创建了两个对象集合，第一个集合使用 `System.Array` 类（这是一个简单数组），第二个集合使用 `System.Collections.ArrayList` 类。这两个集合都是 `Animal` 对象，在 `Animal.cs` 中定义。`Animal` 类是抽象类，所以不能进行实例化。但通过多态性（详见第 8 章），可以使集合中的项成为派生于 `Animal` 类的 `Cow` 和 `Chicken` 类实例。

&emsp;&emsp;在 `Class1.cs` 的 `Main()` 方法中创建好这些数组后，就可以显示其特性和功能。有几个处理操作可以应用到 `Array` 和 `ArrayList` 集合上，但它们的语法略有区别。也有一些操作只能使用更高级的 `ArrayList` 类型。

&emsp;&emsp;下面首先通过比较这两种集合类型的代码和结果，讨论一下类似操作。首先是集合的创建。对于简单数组而言，只有固定的大小来初始化数组，才能使用它。下面使用第 5 章介绍的标准语法创建数组 `animalArray`：

```javascript
	Animal[] animalArray = new Animal[2];
```

&emsp;&emsp;这个类还有另外两个构造函数。第一个构造函数把现有的集合作为一个参数，将其内容复制到新实例中；而另一个构造函数通过一个参数设置集合的容量（`capacity`）。这个容量用一个int值指定，设置集合中可以包含的初始项数。但这并不是绝对容量，因为如果集合中的项数超过了这个值，容量就会自动增加一倍。

&emsp;&emsp;因为数组是引用类型（例如，`Animal` 和 `Animal` 派生的对象），所以用一个长度初始化数组并没有初始化它所包含的项。要使用一个指定的项，该项还需要初始化，即需要给这个项赋予初始化了的对象：

```javascript
	Cow myCow1 = new Cow("Deirdre");
	animalArray[0] = myCow1;
	animalArray[1] = new Chicken("Ken");
```

&emsp;&emsp;这段代码以两种方式完成该初始化任务： 用现有的 `Cow` 对象来赋值，或者通过创建一个新的 `Chicken` 对象来赋值。主要区别在于前者引用了数组中的对象--我们在代码的后面就使用了这种方式。

&emsp;&emsp;**对于 `ArrayList` 集合，它没有现成的项，也没有 `null` 引用的项**。这样就不能以相同的方式给索引赋予新实例。我们使用 `ArrayList` 对象的 `Add()` 方法添加新项：

```javascript
	Cow myCow2 = new Cow("Hayley");
	animalArrayList.Add(myCow2);
	animalArrayList.Add(new Chicken("Roy"));
```

&emsp;&emsp;除语法稍有不同外，还可以采用相同的方式把新对象或现有对象添加到集合中。以这种方式添加完项后，就可以使用与数组相同的语法来改写它们，例如：

```javascript
	animalArrayList[0] = new Cow("Anima");
```

&emsp;&emsp;但不能在这个示例中这么做。

&emsp;&emsp;第 5 章介绍了如何使用 `foreach` 结构迭代一个数组。这是可以的，因为 `System.Array` 类实现了 `IEnumerable` 接口，这个接口的唯一方法 `GetEnumerator()` 可以迭代集合中的各项。后面将更加深入地讨论这一点。在代码中，我们写出了数组中每个 `Animal` 对象的信息：

```javascript
	foreach (Animal myAnimal in animalArray)
	{
		Console.WriteLine("New {0} object added to Array collection, " + 
				  "Name = {1}", myAnimal.ToString(), myAnimal.Name);
	}
```

&emsp;&emsp;这里使用的 `ArrayList` 对象也支持 `IEnumerable` 接口，并可以与 `foreach` 一起使用，此时语法是相同的：


```javascript
	foreach (Animal myAnimal in animalArrayList)
	{
		Console.WriteLine("New {0} object added to ArrayList collection, " + 
				  "Name = {1}", myAnimal.ToString(), myAnimal.Name);
	}
```


&emsp;&emsp;接着使用数组的 `Length` 属性，在屏幕上输出数组中元素的个数：

```javascript
	Console.WriteLine("Array collection contains {0} objects.", animalArray.Length);
```


&emsp;&emsp;也可以使用 `ArrayList` 集合得到相同的结果，但要使用 `Count` 属性，该属性是 `ICollection` 接口的一部分：

```javascript
	Console.WriteLine("ArrayList collection contains {0} objects.", animalArrayList.Count);
```








🔚