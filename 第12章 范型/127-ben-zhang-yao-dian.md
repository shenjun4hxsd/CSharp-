##本章要点

|主题|要点|
|:--|:--|
|使用泛型类型|泛型类型需要一个或多个类型参数才能工作。<br>在声明变量时，传送需要的类型参数，就可以把泛型类型用作变量的类型。为此，应把逗号分隔的类型名列表放在尖括号中|
|可空类型|可空类型可使用指定类型的任意值或null值。<br>使用`Nullable<T>`或T？语法，可以声明可空类型的变量|
|??运算符|空接合运算符返回第一个操作数的值，如果第一个操作数是null，就返回第二个操作数的值|
|泛型集合|泛型集合非常有用，因为它们内置了强类型化功能。<br>可使用`List<T>`、`Collection<T>`和`Dictionary<K, V>`等集合类型，它们还提供了泛型接口。为了针对泛型集合进行排序和搜索，应使用`IComparer<T>`和`IComparable<T>`接口|
|定义泛型类|泛型类型的定义十分类似于其他类型，但在指定类型名时需要添加泛型类型参数。<br>与使用泛型类型一样，也需要把这些参数指定为逗号分隔的列表，并放在尖括号中。在使用类型名的地方都可以使用泛型类型参数，例如可在方法的返回值和参数中使用它们|
|泛型类型的参数约束|为了高效地在泛型类型代码中使用泛型类型参数，可以在使用类型时约束可以提供的类型。可以根据基类、所支持的接口、是否必须是值类型或引用类型以及是否支持无参数的构造函数等，来约束类型参数。<br>如果没有这些约束，就必须使用default关键字来实例化泛型类型的变量|
|其他泛型类型|除类之外，还可以定义泛型接口、委托和方法|
|变体|变体是类似于多态性的一个概念，但应用于类型参数。<br>它允许使用一个泛型类型替代另一个泛型类型，这些泛型类型仅在所使用的泛型类型参数上有区别。<br>协变允许在两种类型之间转换，其中目标类型有一个类型参数，它是源类型的类型参数的基类。<br>抗变允许进行相反的转换。<br>协变类型参数用out参数定义，只能用作返回类型和属性get访问器的类型。<br>抗变类型参数用in参数定义，只能用作方法的参数|


🔚