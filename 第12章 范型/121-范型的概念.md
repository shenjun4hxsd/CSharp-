##泛型的概念

&emsp;&emsp;为了介绍泛型的概念，说明它们为什么这么有用，先回顾一下第11章中的集合类。基本集合可以包含在类似`ArrayList`这样的类中，但这些集合是没有类型化的，所以需要把`object`项转换为集合中实际存储的对象类型。继承自System.Object的任何对象都可以存储在`ArrayList`中，所以要特别仔细。假定包含在集合中的某些类型可能导致抛出异常，而且代码逻辑崩溃。前面介绍的技术可以处理这个问题，包括检查对象类型所需要的代码。

&emsp;&emsp;但是，更好的解决方法是一开始就使用强类型化的集合类。这种集合类派生于CollectionBase，并可以拥有自己的方法，来添加、删除和访问集合的成员，但它可能把集合成员限制为派生于某种基本类型，或者必须支持某个接口。这会带来一个问题。每次创建需要包含集合中的新类时，就必须执行下列任务之一：

```
    • 使用某个集合类，该类已经定义为可以包含新类型的项。
    • 创建一个新的集合类，它可以包含新类型的项，实现所有需要的方法。
```

&emsp;&emsp;一般情况下，新的类型需要额外的功能，所以常常需要用到新的集合类，因此创建集合类会花费大量时间。

&emsp;&emsp;另一方面，泛型类大大简化了这个问题。泛型类是以实例化过程中提供的类型或类为基础建立的，可以毫不费力地对对象进行强类型化。对于集合，创建“T类型对象的集合”十分简单，只需编写一行代码即可。不使用下面的代码：

```csharp
    CollectionClass items = new CollectionClass();
    items.Add(new ItemClass());
```
&emsp;&emsp;而是使用：

```csharp
    CollectionClass<ItemClass> items = new CollectionClass<ItemClass>();
    items.Add(new ItemClass());
```
&emsp;&emsp;尖括号语法是把类型参数传送给泛型类型的方式。在上面的代码中，应把`CollectionClass<ItemClass>`看做ItemClass的CollectionClass。当然，本章后面会详细探讨这个语法。

&emsp;&emsp;泛型不只涉及集合，但是集合特别适合使用泛型。本章在后面介绍System.Collections.Generic名称空间时会看到这一点。创建一个泛型类，就可以生成一些方法，它们的签名可以强类型化为我们需要的任何类型，该类型甚至可以是值类型或引用类型，处理各自的操作。还可以把用于实例化泛型类的类型限制为支持某个给定的接口，或派生自某种类型，从而只允许使用类型的一个子集。泛型并不限于类，还可以创建泛型接口、泛型方法（可以在非泛型类上定义），甚至泛型委托。这将极大地提高代码的灵活性，正确使用泛型可以显著缩短开发时间。

&emsp;&emsp;那么该如何实现泛型呢？通常，在创建类时，它会编译为一个类型，然后在代码中使用。读者可能认为，在创建泛型类时，它必须被编译为许多类型，才能进行实例化。幸好并不是这样：在.NET 中，类有无限多个。在后台，.NET运行库允许在需要时动态生成泛型类。在实例化之前，B的某个泛型类A甚至不存在。

>&emsp;&emsp;**对于熟悉C++或对C++感兴趣的读者来说，这是C++模板和C#泛型类的一个区别。在C++中，编译器可以检测出在哪里使用了模板的某个特定类型，例如，模板B的A类型，然后编译需要的代码，来创建这个类型。而在C#中，所有操作都在运行期间进行。**

&emsp;&emsp;总之，泛型允许灵活地创建类型，处理一种或多种特定类型的对象，这些类型是在实例化时确定的，否则就使用泛型类型。下面看看如何在实际中使用它们。


🔚
